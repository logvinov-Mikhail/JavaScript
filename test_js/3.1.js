// СОЗДАНИЕ СОБСТВЕННЫХ ИСКЛЮЧЕНИЙ
    //Для выбрасывания исключения используется конструкция throw .

//ОБЪЕКТ ОШИБКИ
    //Примитивы, вроде текста или чисел не используются как ошибки.Для
    //ошибок существует класс Error.

        const divider = (a, b) => {
            if(b == 0){
            const divideError = new Error("Ошибка деления на 0");
            throw divideError;
            // или throw new Error("Ошибка деления на 0");
            }
            return a / b;
        };
            
        console.log(divider(5, 2)); // 0.5;
        //console.log(divider(1,0)); // "Ошибка деления на 0";

// ПЕРЕХВАТ ИСКЛЮЧЕНИЙ
// ЗАЧЕМ ПЕРЕХВАТЫВАТЬ ИСКЛЮЧЕНИЯ?
    // 1. Например, при возникновении ошибки необходимо сообщить об этом
    // пользователю как-то культурно
    // 2. Например, при возникновении ошибки необходимо получить
    // расширенную информацию
    // 3. Например, случившаяся ошибка не должна прерывать выполнение
    // дальнейшего кода

// Конструкция try..catch состоит из блоков:
    // — try ;
    // — catch ;
    // — finally .
        try {
            console.lo('Ошибка не произошла!'); // .. код, который может выполниться неверно
        } catch(e) {
            console.log('Ошибка произошла!'); // .. код, который в этом случае выполнится
        } finally {
            console.log('ошибка не повлияла на этот код в блоке finally');// .. код, который выполнится в любом случае
        }

    // ОГРАНИЧЕНИЯ ДЛЯ try...catch
    // Перехват ошибки НЕ СРАБОТАЕТ:
    // — если имеется синтакcическая ошибка;
    // Перехват ошибки НЕ СРАБОТАЕТ:
    // — если код, в котором произошла ошибка работает асинхронно по
    // отношению к try...catch .

// КОНСОЛЬНЫЕ МЕТОДЫ ДЛЯ УДОБНОЙ РАБОТЫ
    // console.log() - ВЫВОД НА КОНСОЛЬ
    // console.clear() - ОЧИСТКА КОНСОЛИ
    // console.table() - ФОРМАТИРОВАННЫЙ ВЫВОД
    // console.time() и console.timeEnd() - ЗАМЕР ВРЕМЕНИ ВЫПОЛНЕНИЯ КОДА
    // (в метод передаётся id таймера). Таким образом можно получить время выполнения цикла из 10000 итераций.

// ОБЛАСТИ ВИДИМОСТИ
        let firstName = 'Олег';
            function showGreeting( person ) {
            console.log( `С днём рождения, ${person}!` );
        }
        showGreeting( firstName );

        function keepSecret() {
            let secret = 'Ленин - гриб!';
            console.log( secret ); // Выведет «Ленин - гриб!»
        }
            // Выдаст ошибку «Can't find variable: secret»
        //console.log( secret );

// ЗАМЫКАНИЯ.ОКРУЖЕНИЕ
// УНИЧТОЖЕНИЕ
    // Попробуем создать в tick переменную и сразу же увеличить её на 1:
        function tick() {
            let start = 1;  
            console.log( start++ );
        }
        tick(); // 1
        tick(); // 1
        tick(); // 1
    //Почему это не работает? Дело в том, что start создается и уничтожается с каждым новым вызовом tick .
    // ПЕРЕМЕННЫЕ В ГЛОБАЛЬНОЙ ОБЛАСТИ ВИДИМОСТИ
        let start2 = 1;
        function tick2() {
            console.log( start2++ );
        }
        tick2(); // 1
        tick2(); // 2
        tick2(); // 3
    // В таком случае start уничтожится только после того как посетитель
    // закроет вкладку. Иными словами, переменные в глобальной области
    // видимости не уничтожаются из памяти. Переменные функциональной
    // области видимости доступны только на время выполнения функции.

// ЗАМЫКАНИЯ      
    // Замыкания—это функция вместе со всеми внешними переменными,
    // которые ей доступны.Другими словами, функция, определённая в
    // замыкании, «запоминает» окружение, в котором она была создана.
    // В нашем случае замыканием является функция tick .
        let start3 = 1;
        function tick3() {
            console.log( start3++ );
        }
    
// ЗАМЫКАНИЯ. ПОЯСНЕНИЕ (ДЕМО)
    // В нашем случае замыканием является вложенная в createCounter
    // функция, которая использует аргумент start , находящийся в области
    // видимости вне createCounter .
    // Как происходит поиск переменных и функций по областям видимости?
    function createCounter( start4 = 0 ) {
        return function() {
            console.log( start4++ );
        }
    }
    let tick4 = createCounter( 1 ), // начинаем считать с 1
        tick10 = createCounter( 10 ); // начинаем считать с 10

        tick4(); // 1
        tick4(); // 2
        tick4(); // 3
        tick10(); // 10
        tick10(); // 11
        tick10(); // 12
// ПОИСК В ОБЛАСТЯХ ВИДИМОСТИ
    // Если в текущей области видимости какая-то переменная не была найдена,
    // она ищется в области видимости выше (включая глобавльную).
              
    // Если переменная не найдена ни в одной области видимости, мы получим
    // ошибку.
        function leninHistory() {
            let leninName = 'Владимир';
                console.log(`Меня зовут ${leninName}, у меня нет предшественников`)

            function stalinHistory() {
                let stalinName = 'Иосиф';
                console.log(`Меня зовут ${stalinName}, Имя моего предшественника: ${leninName}`);

                function medvedevHistory() {
                    let medvedevName = 'Дмитрий';
                    console.log(`Меня зовут ${medvedevName}, Имена моих предшественников: ${stalinName}, ${leninName}`);
                }
                medvedevHistory();
            }
            // не забываем выполнить объявленную функцию
            stalinHistory();
        }
        leninHistory()
        
// КОНСТРУКЦИЯ delete
    // Во время выполнения скрипта для каждого примитива или объекта
    // выделяется определенный участок памяти.
    // Память не бесконечна, поэтому ее требуется периодически очищать от
    // "мусора"- неиспользуемых значений переменных, объектов и их свойств.
    // За этим следит"сборщик мусора"- алгоритм, очищающий память.

    // Как понять, можно ли удалить какое-то значение? Это просто. Значение
    // считается неиспользуемым, если на него не ведет никакая ссылка.

    // 1. delete возвращает false только если свойство существует, но не
    // может быть удалено, и true - в любых других случаях.
    // 2. С помощью delete можно удалить только свойство объекта, а значит,
    // нельзя удалить переменные (объявленные через var и let );
    // 3. при удалении элемента массива, в массиве сохраняется "пустое место"
    // ( empty ) от этого элемента,то есть длина массива при этом не изменится;
    // 4. delete не изменяет прототип объекта;
    // 5. существуют свойства,которые нельзя удалить. Например:
        f = [1,2,'third'];
        delete f.length; // false


        console.log('');
        console.log('Домашка');
        console.log('');

// Задача №1 
/*
function parseCount(result) {
    let resultParse = Number.parseInt(result);
    if (isNaN(resultParse)) {
        throw numberError = new Error("Невалидное значение");
    } else {
        return resultParse;
    }
}

function validateCount(count) {
    try {
        return parseCount(count);  
    } catch(e) {
        return numberError; 
    }      
}

// Задача №2 

class Triangle {
    constructor(a, b, c) {
        this.a = a;
        this.b = b;
        this.c = c;

        try {
            if ((a + b) < c || (a + c) < b || (b + c) < a) {
                
                const trError = new Error("Треугольник с такими сторонами не существует");
                throw trError;
            } 
        } catch(e) {
            console.log("ошибку перехватил");  
        } 
    }
    
    getPerimeter() {
        return (this.a + this.b + this.c);
    }

    getArea() {
        const p = (this.a + this.b + this.c)*0.5; //Вычисление полупериметра
        const s = Math.sqrt(p * (p - this.a) * (p - this.b) * (p - this.c)); //Вычисление площади
        return s.toFixed(3);
    }
}

const test = new Triangle(3, 2, 4);
console.log(test);
console.log(test.getPerimeter());
console.log(test.getArea());

function getTriangle(a, b, c) {
    
    // try {

    // } catch(e) {
    //     const trError = new Error("Треугольник с такими сторонами не существует");
    //     throw trError; 
    // }   
    return new Triangle(a, b, c); 
}

*/
